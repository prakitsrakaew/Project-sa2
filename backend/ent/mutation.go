// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/prakitsrakaew/app/ent/bill"
	"github.com/prakitsrakaew/app/ent/billingstatus"
	"github.com/prakitsrakaew/app/ent/employee"
	"github.com/prakitsrakaew/app/ent/repairinvoice"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBill          = "Bill"
	TypeBillingstatus = "Billingstatus"
	TypeEmployee      = "Employee"
	TypeRepairinvoice = "Repairinvoice"
)

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	price                 *int
	addprice              *int
	time                  *int
	addtime               *int
	clearedFields         map[string]struct{}
	_Repairinvoice        *int
	cleared_Repairinvoice bool
	_Employee             *int
	cleared_Employee      bool
	_Billingstatus        *int
	cleared_Billingstatus bool
	done                  bool
	oldValue              func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrice sets the price field.
func (m *BillMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *BillMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to price.
func (m *BillMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *BillMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice reset all changes of the "price" field.
func (m *BillMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetTime sets the time field.
func (m *BillMutation) SetTime(i int) {
	m.time = &i
	m.addtime = nil
}

// Time returns the time value in the mutation.
func (m *BillMutation) Time() (r int, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old time value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to time.
func (m *BillMutation) AddTime(i int) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the time field in this mutation.
func (m *BillMutation) AddedTime() (r int, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ResetTime reset all changes of the "time" field.
func (m *BillMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
}

// SetRepairinvoiceID sets the Repairinvoice edge to Repairinvoice by id.
func (m *BillMutation) SetRepairinvoiceID(id int) {
	m._Repairinvoice = &id
}

// ClearRepairinvoice clears the Repairinvoice edge to Repairinvoice.
func (m *BillMutation) ClearRepairinvoice() {
	m.cleared_Repairinvoice = true
}

// RepairinvoiceCleared returns if the edge Repairinvoice was cleared.
func (m *BillMutation) RepairinvoiceCleared() bool {
	return m.cleared_Repairinvoice
}

// RepairinvoiceID returns the Repairinvoice id in the mutation.
func (m *BillMutation) RepairinvoiceID() (id int, exists bool) {
	if m._Repairinvoice != nil {
		return *m._Repairinvoice, true
	}
	return
}

// RepairinvoiceIDs returns the Repairinvoice ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoiceID instead. It exists only for internal usage by the builders.
func (m *BillMutation) RepairinvoiceIDs() (ids []int) {
	if id := m._Repairinvoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoice reset all changes of the "Repairinvoice" edge.
func (m *BillMutation) ResetRepairinvoice() {
	m._Repairinvoice = nil
	m.cleared_Repairinvoice = false
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *BillMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *BillMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *BillMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *BillMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *BillMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *BillMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// SetBillingstatusID sets the Billingstatus edge to Billingstatus by id.
func (m *BillMutation) SetBillingstatusID(id int) {
	m._Billingstatus = &id
}

// ClearBillingstatus clears the Billingstatus edge to Billingstatus.
func (m *BillMutation) ClearBillingstatus() {
	m.cleared_Billingstatus = true
}

// BillingstatusCleared returns if the edge Billingstatus was cleared.
func (m *BillMutation) BillingstatusCleared() bool {
	return m.cleared_Billingstatus
}

// BillingstatusID returns the Billingstatus id in the mutation.
func (m *BillMutation) BillingstatusID() (id int, exists bool) {
	if m._Billingstatus != nil {
		return *m._Billingstatus, true
	}
	return
}

// BillingstatusIDs returns the Billingstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BillingstatusID instead. It exists only for internal usage by the builders.
func (m *BillMutation) BillingstatusIDs() (ids []int) {
	if id := m._Billingstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingstatus reset all changes of the "Billingstatus" edge.
func (m *BillMutation) ResetBillingstatus() {
	m._Billingstatus = nil
	m.cleared_Billingstatus = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.price != nil {
		fields = append(fields, bill.FieldPrice)
	}
	if m.time != nil {
		fields = append(fields, bill.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldPrice:
		return m.Price()
	case bill.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldPrice:
		return m.OldPrice(ctx)
	case bill.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case bill.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, bill.FieldPrice)
	}
	if m.addtime != nil {
		fields = append(fields, bill.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldPrice:
		return m.AddedPrice()
	case bill.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case bill.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldPrice:
		m.ResetPrice()
		return nil
	case bill.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Repairinvoice != nil {
		edges = append(edges, bill.EdgeRepairinvoice)
	}
	if m._Employee != nil {
		edges = append(edges, bill.EdgeEmployee)
	}
	if m._Billingstatus != nil {
		edges = append(edges, bill.EdgeBillingstatus)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeRepairinvoice:
		if id := m._Repairinvoice; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeBillingstatus:
		if id := m._Billingstatus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Repairinvoice {
		edges = append(edges, bill.EdgeRepairinvoice)
	}
	if m.cleared_Employee {
		edges = append(edges, bill.EdgeEmployee)
	}
	if m.cleared_Billingstatus {
		edges = append(edges, bill.EdgeBillingstatus)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeRepairinvoice:
		return m.cleared_Repairinvoice
	case bill.EdgeEmployee:
		return m.cleared_Employee
	case bill.EdgeBillingstatus:
		return m.cleared_Billingstatus
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeRepairinvoice:
		m.ClearRepairinvoice()
		return nil
	case bill.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case bill.EdgeBillingstatus:
		m.ClearBillingstatus()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeRepairinvoice:
		m.ResetRepairinvoice()
		return nil
	case bill.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case bill.EdgeBillingstatus:
		m.ResetBillingstatus()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// BillingstatusMutation represents an operation that mutate the Billingstatuses
// nodes in the graph.
type BillingstatusMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	billingstatusname     *string
	clearedFields         map[string]struct{}
	billingstatuss        map[int]struct{}
	removedbillingstatuss map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Billingstatus, error)
}

var _ ent.Mutation = (*BillingstatusMutation)(nil)

// billingstatusOption allows to manage the mutation configuration using functional options.
type billingstatusOption func(*BillingstatusMutation)

// newBillingstatusMutation creates new mutation for $n.Name.
func newBillingstatusMutation(c config, op Op, opts ...billingstatusOption) *BillingstatusMutation {
	m := &BillingstatusMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingstatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingstatusID sets the id field of the mutation.
func withBillingstatusID(id int) billingstatusOption {
	return func(m *BillingstatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Billingstatus
		)
		m.oldValue = func(ctx context.Context) (*Billingstatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Billingstatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingstatus sets the old Billingstatus of the mutation.
func withBillingstatus(node *Billingstatus) billingstatusOption {
	return func(m *BillingstatusMutation) {
		m.oldValue = func(context.Context) (*Billingstatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingstatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingstatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillingstatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBillingstatusname sets the billingstatusname field.
func (m *BillingstatusMutation) SetBillingstatusname(s string) {
	m.billingstatusname = &s
}

// Billingstatusname returns the billingstatusname value in the mutation.
func (m *BillingstatusMutation) Billingstatusname() (r string, exists bool) {
	v := m.billingstatusname
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingstatusname returns the old billingstatusname value of the Billingstatus.
// If the Billingstatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillingstatusMutation) OldBillingstatusname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillingstatusname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillingstatusname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingstatusname: %w", err)
	}
	return oldValue.Billingstatusname, nil
}

// ResetBillingstatusname reset all changes of the "billingstatusname" field.
func (m *BillingstatusMutation) ResetBillingstatusname() {
	m.billingstatusname = nil
}

// AddBillingstatusIDs adds the billingstatuss edge to Bill by ids.
func (m *BillingstatusMutation) AddBillingstatusIDs(ids ...int) {
	if m.billingstatuss == nil {
		m.billingstatuss = make(map[int]struct{})
	}
	for i := range ids {
		m.billingstatuss[ids[i]] = struct{}{}
	}
}

// RemoveBillingstatusIDs removes the billingstatuss edge to Bill by ids.
func (m *BillingstatusMutation) RemoveBillingstatusIDs(ids ...int) {
	if m.removedbillingstatuss == nil {
		m.removedbillingstatuss = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbillingstatuss[ids[i]] = struct{}{}
	}
}

// RemovedBillingstatuss returns the removed ids of billingstatuss.
func (m *BillingstatusMutation) RemovedBillingstatussIDs() (ids []int) {
	for id := range m.removedbillingstatuss {
		ids = append(ids, id)
	}
	return
}

// BillingstatussIDs returns the billingstatuss ids in the mutation.
func (m *BillingstatusMutation) BillingstatussIDs() (ids []int) {
	for id := range m.billingstatuss {
		ids = append(ids, id)
	}
	return
}

// ResetBillingstatuss reset all changes of the "billingstatuss" edge.
func (m *BillingstatusMutation) ResetBillingstatuss() {
	m.billingstatuss = nil
	m.removedbillingstatuss = nil
}

// Op returns the operation name.
func (m *BillingstatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Billingstatus).
func (m *BillingstatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillingstatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.billingstatusname != nil {
		fields = append(fields, billingstatus.FieldBillingstatusname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillingstatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingstatus.FieldBillingstatusname:
		return m.Billingstatusname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillingstatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingstatus.FieldBillingstatusname:
		return m.OldBillingstatusname(ctx)
	}
	return nil, fmt.Errorf("unknown Billingstatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillingstatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingstatus.FieldBillingstatusname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingstatusname(v)
		return nil
	}
	return fmt.Errorf("unknown Billingstatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillingstatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillingstatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillingstatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Billingstatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillingstatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillingstatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingstatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Billingstatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillingstatusMutation) ResetField(name string) error {
	switch name {
	case billingstatus.FieldBillingstatusname:
		m.ResetBillingstatusname()
		return nil
	}
	return fmt.Errorf("unknown Billingstatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillingstatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.billingstatuss != nil {
		edges = append(edges, billingstatus.EdgeBillingstatuss)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillingstatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingstatus.EdgeBillingstatuss:
		ids := make([]ent.Value, 0, len(m.billingstatuss))
		for id := range m.billingstatuss {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillingstatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbillingstatuss != nil {
		edges = append(edges, billingstatus.EdgeBillingstatuss)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillingstatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billingstatus.EdgeBillingstatuss:
		ids := make([]ent.Value, 0, len(m.removedbillingstatuss))
		for id := range m.removedbillingstatuss {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillingstatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillingstatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillingstatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Billingstatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillingstatusMutation) ResetEdge(name string) error {
	switch name {
	case billingstatus.EdgeBillingstatuss:
		m.ResetBillingstatuss()
		return nil
	}
	return fmt.Errorf("unknown Billingstatus edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	employeename     *string
	employeeemail    *string
	password         *string
	clearedFields    map[string]struct{}
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmployeename sets the employeename field.
func (m *EmployeeMutation) SetEmployeename(s string) {
	m.employeename = &s
}

// Employeename returns the employeename value in the mutation.
func (m *EmployeeMutation) Employeename() (r string, exists bool) {
	v := m.employeename
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeename returns the old employeename value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeename: %w", err)
	}
	return oldValue.Employeename, nil
}

// ResetEmployeename reset all changes of the "employeename" field.
func (m *EmployeeMutation) ResetEmployeename() {
	m.employeename = nil
}

// SetEmployeeemail sets the employeeemail field.
func (m *EmployeeMutation) SetEmployeeemail(s string) {
	m.employeeemail = &s
}

// Employeeemail returns the employeeemail value in the mutation.
func (m *EmployeeMutation) Employeeemail() (r string, exists bool) {
	v := m.employeeemail
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeemail returns the old employeeemail value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeeemail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeeemail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeeemail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeemail: %w", err)
	}
	return oldValue.Employeeemail, nil
}

// ResetEmployeeemail reset all changes of the "employeeemail" field.
func (m *EmployeeMutation) ResetEmployeeemail() {
	m.employeeemail = nil
}

// SetPassword sets the password field.
func (m *EmployeeMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *EmployeeMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *EmployeeMutation) ResetPassword() {
	m.password = nil
}

// AddEmployeeIDs adds the employees edge to Bill by ids.
func (m *EmployeeMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Bill by ids.
func (m *EmployeeMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *EmployeeMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *EmployeeMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *EmployeeMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.employeename != nil {
		fields = append(fields, employee.FieldEmployeename)
	}
	if m.employeeemail != nil {
		fields = append(fields, employee.FieldEmployeeemail)
	}
	if m.password != nil {
		fields = append(fields, employee.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEmployeename:
		return m.Employeename()
	case employee.FieldEmployeeemail:
		return m.Employeeemail()
	case employee.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEmployeename:
		return m.OldEmployeename(ctx)
	case employee.FieldEmployeeemail:
		return m.OldEmployeeemail(ctx)
	case employee.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEmployeename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeename(v)
		return nil
	case employee.FieldEmployeeemail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeemail(v)
		return nil
	case employee.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEmployeename:
		m.ResetEmployeename()
		return nil
	case employee.FieldEmployeeemail:
		m.ResetEmployeeemail()
		return nil
	case employee.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeEmployees:
		m.ResetEmployees()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// RepairinvoiceMutation represents an operation that mutate the Repairinvoices
// nodes in the graph.
type RepairinvoiceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	symptomid             *int
	addsymptomid          *int
	deviceid              *int
	adddeviceid           *int
	userid                *int
	adduserid             *int
	statusrepairid        *int
	addstatusrepairid     *int
	clearedFields         map[string]struct{}
	repairinvoices        *int
	clearedrepairinvoices bool
	done                  bool
	oldValue              func(context.Context) (*Repairinvoice, error)
}

var _ ent.Mutation = (*RepairinvoiceMutation)(nil)

// repairinvoiceOption allows to manage the mutation configuration using functional options.
type repairinvoiceOption func(*RepairinvoiceMutation)

// newRepairinvoiceMutation creates new mutation for $n.Name.
func newRepairinvoiceMutation(c config, op Op, opts ...repairinvoiceOption) *RepairinvoiceMutation {
	m := &RepairinvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeRepairinvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepairinvoiceID sets the id field of the mutation.
func withRepairinvoiceID(id int) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Repairinvoice
		)
		m.oldValue = func(ctx context.Context) (*Repairinvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repairinvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepairinvoice sets the old Repairinvoice of the mutation.
func withRepairinvoice(node *Repairinvoice) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		m.oldValue = func(context.Context) (*Repairinvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepairinvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepairinvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RepairinvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptomid sets the symptomid field.
func (m *RepairinvoiceMutation) SetSymptomid(i int) {
	m.symptomid = &i
	m.addsymptomid = nil
}

// Symptomid returns the symptomid value in the mutation.
func (m *RepairinvoiceMutation) Symptomid() (r int, exists bool) {
	v := m.symptomid
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptomid returns the old symptomid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldSymptomid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptomid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptomid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptomid: %w", err)
	}
	return oldValue.Symptomid, nil
}

// AddSymptomid adds i to symptomid.
func (m *RepairinvoiceMutation) AddSymptomid(i int) {
	if m.addsymptomid != nil {
		*m.addsymptomid += i
	} else {
		m.addsymptomid = &i
	}
}

// AddedSymptomid returns the value that was added to the symptomid field in this mutation.
func (m *RepairinvoiceMutation) AddedSymptomid() (r int, exists bool) {
	v := m.addsymptomid
	if v == nil {
		return
	}
	return *v, true
}

// ResetSymptomid reset all changes of the "symptomid" field.
func (m *RepairinvoiceMutation) ResetSymptomid() {
	m.symptomid = nil
	m.addsymptomid = nil
}

// SetDeviceid sets the deviceid field.
func (m *RepairinvoiceMutation) SetDeviceid(i int) {
	m.deviceid = &i
	m.adddeviceid = nil
}

// Deviceid returns the deviceid value in the mutation.
func (m *RepairinvoiceMutation) Deviceid() (r int, exists bool) {
	v := m.deviceid
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceid returns the old deviceid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldDeviceid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceid: %w", err)
	}
	return oldValue.Deviceid, nil
}

// AddDeviceid adds i to deviceid.
func (m *RepairinvoiceMutation) AddDeviceid(i int) {
	if m.adddeviceid != nil {
		*m.adddeviceid += i
	} else {
		m.adddeviceid = &i
	}
}

// AddedDeviceid returns the value that was added to the deviceid field in this mutation.
func (m *RepairinvoiceMutation) AddedDeviceid() (r int, exists bool) {
	v := m.adddeviceid
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceid reset all changes of the "deviceid" field.
func (m *RepairinvoiceMutation) ResetDeviceid() {
	m.deviceid = nil
	m.adddeviceid = nil
}

// SetUserid sets the userid field.
func (m *RepairinvoiceMutation) SetUserid(i int) {
	m.userid = &i
	m.adduserid = nil
}

// Userid returns the userid value in the mutation.
func (m *RepairinvoiceMutation) Userid() (r int, exists bool) {
	v := m.userid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserid returns the old userid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldUserid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserid: %w", err)
	}
	return oldValue.Userid, nil
}

// AddUserid adds i to userid.
func (m *RepairinvoiceMutation) AddUserid(i int) {
	if m.adduserid != nil {
		*m.adduserid += i
	} else {
		m.adduserid = &i
	}
}

// AddedUserid returns the value that was added to the userid field in this mutation.
func (m *RepairinvoiceMutation) AddedUserid() (r int, exists bool) {
	v := m.adduserid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserid reset all changes of the "userid" field.
func (m *RepairinvoiceMutation) ResetUserid() {
	m.userid = nil
	m.adduserid = nil
}

// SetStatusrepairid sets the statusrepairid field.
func (m *RepairinvoiceMutation) SetStatusrepairid(i int) {
	m.statusrepairid = &i
	m.addstatusrepairid = nil
}

// Statusrepairid returns the statusrepairid value in the mutation.
func (m *RepairinvoiceMutation) Statusrepairid() (r int, exists bool) {
	v := m.statusrepairid
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusrepairid returns the old statusrepairid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldStatusrepairid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusrepairid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusrepairid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusrepairid: %w", err)
	}
	return oldValue.Statusrepairid, nil
}

// AddStatusrepairid adds i to statusrepairid.
func (m *RepairinvoiceMutation) AddStatusrepairid(i int) {
	if m.addstatusrepairid != nil {
		*m.addstatusrepairid += i
	} else {
		m.addstatusrepairid = &i
	}
}

// AddedStatusrepairid returns the value that was added to the statusrepairid field in this mutation.
func (m *RepairinvoiceMutation) AddedStatusrepairid() (r int, exists bool) {
	v := m.addstatusrepairid
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusrepairid reset all changes of the "statusrepairid" field.
func (m *RepairinvoiceMutation) ResetStatusrepairid() {
	m.statusrepairid = nil
	m.addstatusrepairid = nil
}

// SetRepairinvoicesID sets the repairinvoices edge to Bill by id.
func (m *RepairinvoiceMutation) SetRepairinvoicesID(id int) {
	m.repairinvoices = &id
}

// ClearRepairinvoices clears the repairinvoices edge to Bill.
func (m *RepairinvoiceMutation) ClearRepairinvoices() {
	m.clearedrepairinvoices = true
}

// RepairinvoicesCleared returns if the edge repairinvoices was cleared.
func (m *RepairinvoiceMutation) RepairinvoicesCleared() bool {
	return m.clearedrepairinvoices
}

// RepairinvoicesID returns the repairinvoices id in the mutation.
func (m *RepairinvoiceMutation) RepairinvoicesID() (id int, exists bool) {
	if m.repairinvoices != nil {
		return *m.repairinvoices, true
	}
	return
}

// RepairinvoicesIDs returns the repairinvoices ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoicesID instead. It exists only for internal usage by the builders.
func (m *RepairinvoiceMutation) RepairinvoicesIDs() (ids []int) {
	if id := m.repairinvoices; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoices reset all changes of the "repairinvoices" edge.
func (m *RepairinvoiceMutation) ResetRepairinvoices() {
	m.repairinvoices = nil
	m.clearedrepairinvoices = false
}

// Op returns the operation name.
func (m *RepairinvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repairinvoice).
func (m *RepairinvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RepairinvoiceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.symptomid != nil {
		fields = append(fields, repairinvoice.FieldSymptomid)
	}
	if m.deviceid != nil {
		fields = append(fields, repairinvoice.FieldDeviceid)
	}
	if m.userid != nil {
		fields = append(fields, repairinvoice.FieldUserid)
	}
	if m.statusrepairid != nil {
		fields = append(fields, repairinvoice.FieldStatusrepairid)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RepairinvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.Symptomid()
	case repairinvoice.FieldDeviceid:
		return m.Deviceid()
	case repairinvoice.FieldUserid:
		return m.Userid()
	case repairinvoice.FieldStatusrepairid:
		return m.Statusrepairid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RepairinvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.OldSymptomid(ctx)
	case repairinvoice.FieldDeviceid:
		return m.OldDeviceid(ctx)
	case repairinvoice.FieldUserid:
		return m.OldUserid(ctx)
	case repairinvoice.FieldStatusrepairid:
		return m.OldStatusrepairid(ctx)
	}
	return nil, fmt.Errorf("unknown Repairinvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptomid(v)
		return nil
	case repairinvoice.FieldDeviceid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceid(v)
		return nil
	case repairinvoice.FieldUserid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserid(v)
		return nil
	case repairinvoice.FieldStatusrepairid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusrepairid(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RepairinvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addsymptomid != nil {
		fields = append(fields, repairinvoice.FieldSymptomid)
	}
	if m.adddeviceid != nil {
		fields = append(fields, repairinvoice.FieldDeviceid)
	}
	if m.adduserid != nil {
		fields = append(fields, repairinvoice.FieldUserid)
	}
	if m.addstatusrepairid != nil {
		fields = append(fields, repairinvoice.FieldStatusrepairid)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RepairinvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.AddedSymptomid()
	case repairinvoice.FieldDeviceid:
		return m.AddedDeviceid()
	case repairinvoice.FieldUserid:
		return m.AddedUserid()
	case repairinvoice.FieldStatusrepairid:
		return m.AddedStatusrepairid()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSymptomid(v)
		return nil
	case repairinvoice.FieldDeviceid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceid(v)
		return nil
	case repairinvoice.FieldUserid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserid(v)
		return nil
	case repairinvoice.FieldStatusrepairid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusrepairid(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RepairinvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RepairinvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepairinvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repairinvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetField(name string) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		m.ResetSymptomid()
		return nil
	case repairinvoice.FieldDeviceid:
		m.ResetDeviceid()
		return nil
	case repairinvoice.FieldUserid:
		m.ResetUserid()
		return nil
	case repairinvoice.FieldStatusrepairid:
		m.ResetStatusrepairid()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RepairinvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repairinvoices != nil {
		edges = append(edges, repairinvoice.EdgeRepairinvoices)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RepairinvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		if id := m.repairinvoices; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RepairinvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RepairinvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RepairinvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrepairinvoices {
		edges = append(edges, repairinvoice.EdgeRepairinvoices)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RepairinvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		return m.clearedrepairinvoices
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RepairinvoiceMutation) ClearEdge(name string) error {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		m.ClearRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetEdge(name string) error {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		m.ResetRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice edge %s", name)
}
